{"version":3,"file":"index7.js","sources":["../src/index7.ts"],"sourcesContent":["interface GameOptions {\r\n    cycles: number\r\n    zipFile: string\r\n    execCmdArray: string[]\r\n}\r\n\r\ninterface KeyMapping {\r\n    targetKey: string\r\n    replacementKeyCode: number\r\n}\r\n\r\ninterface Directions {\r\n    directions: number\r\n}\r\n\r\ninterface ButtonMapping {\r\n    element:HTMLElement\r\n    asciiCode:number\r\n}\r\n\r\ninterface Origin {\r\n    x: number\r\n    y: number\r\n    id: number\r\n}\r\n\r\ninterface PixelListener {\r\n    x: number\r\n    y: number\r\n    callback: (string) => void\r\n    lastColor: string\r\n}\r\n\r\ninterface DirectionMapping {\r\n    direction:string\r\n    asciiMapping:number\r\n}\r\n\r\n/**\r\n * DosGame. Object and helper methods to make it easier to run DOS games in a browser using DOSBox\r\n * @Author Mark van Wyk\r\n * @copyright Emerge Gaming @copy; 2021\r\n */\r\nexport class DosGame {\r\n\r\n    private dosRef: any;\r\n    private options: GameOptions\r\n    private canvas: HTMLCanvasElement\r\n    private rootElement: HTMLElement\r\n    private emulators: any;\r\n    private ci: any\r\n    private keysToReplace:KeyMapping[] = []\r\n    private directions:Directions\r\n    private buttons:ButtonMapping[] = []\r\n    private origin:Origin = {x:null, y:null, id:null}\r\n    private lastDirection:string[] = []\r\n    private canvasContext:CanvasRenderingContext2D\r\n    private interval:number\r\n    private pixelListeners:PixelListener[] = []\r\n    private keysDown:string[] = []\r\n    private readonly forceKeyPress:boolean;\r\n    private generalPixelCallback: (colours:string[]) => void;\r\n    private dPadMode:boolean = false;\r\n    private dPadBounds:DOMRect;\r\n    private touchEventListenersAdded:boolean = false;\r\n\r\n    private directionMapping:object = {\r\n        'up': 38,\r\n        'down':40,\r\n        'left':37,\r\n        'right':39\r\n    };\r\n\r\n\r\n    /**\r\n     * Create a new DosGame object.\r\n     * that this object requires the JSDos script to be loaded by the page.\r\n     *\r\n     * eg: <script src=\"/dosbox/js-dos.js\"></script>\r\n     *\r\n     * @param dosRef a reference to window.DOS created by the included JavaScript file\r\n     * @param options {cycles:number, zipFile:string, execCmd:string[]}\r\n     * @param canvas reference to the HTMLCanvasElement DOSBox is being rendered on\r\n     * @param forceKeyPress force simulateKeyPress instead of simulateKeyEvent\r\n     * @see https://js-dos.com/\r\n     */\r\n\r\n\r\n    \r\n\r\n    constructor(dosRef:any, rootElement:HTMLElement, emulators:any, forceKeyPress:boolean = false) {\r\n        this.dosRef = dosRef;\r\n        //this.options = options;\r\n        //this.canvas = <HTMLCanvasElement>rootElement.firstChild\r\n        this.rootElement = rootElement;\r\n        this.forceKeyPress = forceKeyPress;\r\n        this.emulators = emulators;\r\n    }\r\n\r\n\r\n\r\n    \r\n\r\n    public start():Promise<any> {\r\n        return new Promise((resolve) => {\r\n            this.dosRef(this.canvas, {\r\n                cycles: this.options.cycles,\r\n                wdosboxUrl: '/dosbox/wdosbox.js',\r\n                onprogress: () => {},\r\n                log: () => {}\r\n            }).ready((fs, main) => {\r\n                fs.extract(this.options.zipFile).then(() => {\r\n                    main(this.options.execCmdArray).then((ci) => {\r\n                        this.ci = ci\r\n                        resolve(ci)\r\n                        window.focus();\r\n                        window.addEventListener('unload', this.unload)\r\n                    })\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n    public start7(gameBundle: string):Promise<any> {\r\n        return new Promise((resolve)=>{\r\n            this.emulators.pathPrefix = \"/dosbox/dos7/\";\r\n            this.dosRef(this.rootElement).run(gameBundle).then((ci)=>{\r\n                console.log(\"CI:\" + ci);\r\n                resolve(ci);\r\n            });\r\n        })\r\n    }\r\n\r\n    public getCommandInterface():object {\r\n\r\n        return this.ci;\r\n    }\r\n\r\n\r\n    public startWithConf(dosboxConf):Promise<any> {\r\n        return new Promise((resolve) => {\r\n            this.options.execCmdArray.push('-conf');\r\n            this.options.execCmdArray.push('dosbox.conf')\r\n            this.dosRef(this.canvas, {\r\n                wdosboxUrl: '/dosbox/wdosbox.js',\r\n            }).ready((fs, main) => {\r\n                fs.extract(this.options.zipFile).then(() => {\r\n                    fs.createFile(\"dosbox.conf\", dosboxConf);\r\n                    main(this.options.execCmdArray).then((ci) => {\r\n                        this.ci = ci\r\n                        resolve(ci)\r\n                        window.focus();\r\n                        window.addEventListener('unload', this.unload)\r\n                    })\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Capture a key (hopefully before the emulator gets it and replace it with a different key\r\n     * @param targetKey the event.key (not the ascii code) we're looking for.\r\n     * @param replacementKeyCode the ASCII key to send to DOSBox\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n     */\r\n    public overrideKey(targetKey:string, replacementKeyCode:number):void {\r\n        if (this.keysToReplace.length === 0) this.addKeyEventListeners()\r\n        this.keysToReplace.push({targetKey:targetKey, replacementKeyCode:replacementKeyCode})\r\n    }\r\n\r\n    /**\r\n     * Convert touch dragging to direction keys\r\n     * @param directions can be 8 (including diagonals), 4 (up, down, left right) or 2 (left or right)\r\n     *\r\n     */\r\n    public mapTouchToArrowKeys(directions:Directions):void {\r\n        this.directions = directions\r\n        if (this.buttons.length == 0) {\r\n            this.addTouchEventListeners()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use the D-Pad instead of the touch dragging (joystick)\r\n     * @param dPadElem the HTMLElement of the bounding (div) of the D-Pad container. Used to assess where the finder is.\r\n     */\r\n    public mapDPadToArrowKeys(dPadElem):void {\r\n\r\n        this.dPadBounds = dPadElem.getBoundingClientRect();this.dPadMode = true;\r\n        this.addTouchEventListeners();\r\n    }\r\n\r\n    /**\r\n     * Map an on-screen button to a keypress.\r\n     * @param buttonMapping the keyCode and asciiCode mapping.\r\n     */\r\n    public mapButtonToKey(buttonMapping:ButtonMapping):void {\r\n        this.buttons.push(buttonMapping)\r\n        if (!this.directions) {\r\n            this.addTouchEventListeners()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Automatically press a key after a certain period of time\r\n     * @param asciiCode the asciiCode of the key to press\r\n     * @param wait the wait period in milliseconds\r\n     */\r\n    public autoKeyPress(asciiCode:number, wait:number = 0):Promise<any> {\r\n        return new Promise<unknown>((resolve, reject) =>\r\n            setTimeout (() => {\r\n                this.ci.simulateKeyPress(asciiCode);\r\n                if (wait > 0 && resolve) resolve(null);\r\n            }, wait)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Give the x y coordinate of a pixel with a callback to be called when the colour changes\r\n     * @param x coord of pixel\r\n     * @param y coord of pixel\r\n     * @param callback\r\n     * @param delay the number of ms to wait\r\n     * @todo: This should really be called addPixelListener (i.e. more than one)\r\n     * @deprecated use addPixelListener\r\n     */\r\n    public setPixelListener(x:number, y:number, callback, delay:number = 1000) {\r\n        this.addPixelListener(x, y, callback, delay);\r\n    }\r\n\r\n    /**\r\n     * Give the x y coordinate of a pixel with a callback to be called when the colour changes\r\n     * @param x coord of x pixel\r\n     * @param y coord of y pixel\r\n     * @param callback to callback every interval with the pixel colour.\r\n     * @param delay the number of ms between callback intervals\r\n     */\r\n    public addPixelListener(x:number, y:number, callback, delay:number = 1000) {\r\n        if (!this.interval) this.interval = window.setInterval(this.doIntervalPoll.bind(this), delay)\r\n        this.pixelListeners.push({x:x, y:y, callback:callback, lastColor:undefined})\r\n\r\n        if (!this.canvasContext) this.canvasContext = this.canvas.getContext('2d');\r\n    }\r\n\r\n    public setGeneralPixelCallback(callback:(colours:string[]) => void) {\r\n        this.generalPixelCallback = callback;\r\n    }\r\n\r\n    public stopPixelListener() {\r\n        window.clearInterval(this.interval);\r\n    }\r\n\r\n    public consoleScreenshots() {\r\n        setInterval(() => {\r\n            console.log (this.canvas.toDataURL('img/png'));\r\n        }, 1500)\r\n\r\n    }\r\n\r\n    public static isTouch = () => {\r\n        return (('ontouchstart' in window) ||\r\n            (navigator.maxTouchPoints > 0) ||\r\n            (navigator.msMaxTouchPoints > 0));\r\n    }\r\n\r\n    public overrideDirectionAscii = (directionAscii:object) => {\r\n        this.directionMapping = directionAscii;\r\n    }\r\n\r\n    /***** P R I V A T E   M E T H O D S *****/\r\n\r\n    private doIntervalPoll() {\r\n\r\n        let colors:string[] = []\r\n\r\n        this.pixelListeners.forEach((pl) => {\r\n            let pixelColor:ImageData = this.canvasContext.getImageData(pl.x, pl.y, 1, 1);\r\n            let colorValue:string = '#' + DosGame.getHexValue(pixelColor.data[0]) + DosGame.getHexValue(pixelColor.data[1]) + DosGame.getHexValue(pixelColor.data[2]);\r\n            colors.push(colorValue)\r\n            if (colorValue != pl.lastColor) {\r\n                pl.callback(colorValue);\r\n                pl.lastColor = colorValue;\r\n            }\r\n        });\r\n\r\n        if (this.generalPixelCallback) this.generalPixelCallback(colors);\r\n    }\r\n\r\n    private static getHexValue(number:number):string {\r\n        return (\"00\" + number.toString(16)).slice(-2)\r\n    }\r\n\r\n    /**\r\n     * Create key event listeners\r\n     * @private\r\n     */\r\n    private addKeyEventListeners() {\r\n        window.addEventListener('keyup', this.handleKeyEvent.bind(this))\r\n        window.addEventListener('keydown', this.handleKeyEvent.bind(this))\r\n    }\r\n\r\n    /**\r\n     * Create touch listeners\r\n     */\r\n    private addTouchEventListeners() {\r\n        if (!this.touchEventListenersAdded) {\r\n            document.addEventListener('touchstart', this.handleTouchEvent.bind(this))\r\n            document.addEventListener('touchend', this.handleTouchEvent.bind(this))\r\n            document.addEventListener('touchmove', this.handleTouchEvent.bind(this))\r\n            this.touchEventListenersAdded = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When a key is pressed (keydown) or released (keyup), check to see if it's a mapped key and rather send the\r\n     * preferred key to DosBox.\r\n     * @param event KeyboardEvent of the pressed or released key\r\n     * @private\r\n     */\r\n    private handleKeyEvent(event:KeyboardEvent) {\r\n\r\n        if ((event.type === 'keydown' || event.type === 'keyup') && event.metaKey == false) {\r\n            let keyCode = this.findReplacementKeyCode(event.key);\r\n            if (keyCode) {\r\n                if (event.type === 'keydown' && !this.keysDown.includes(event.key)) {\r\n                    this.forceKeyPress ? this.ci.simulateKeyPress(keyCode, true) : this.ci.simulateKeyEvent(keyCode, true)\r\n                    this.keysDown.push(event.key)\r\n                }\r\n\r\n                if (event.type === 'keyup' && this.keysDown.includes(event.key)) {\r\n                    this.forceKeyPress ? this.ci.simulateKeyPress(keyCode, false) : this.ci.simulateKeyEvent(keyCode, false)\r\n                    this.keysDown.splice(this.keysDown.indexOf(event.key),1);\r\n                }\r\n\r\n                event.stopImmediatePropagation();\r\n                event.stopPropagation();\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    private findReplacementKeyCode(key:string) {\r\n        return this.keysToReplace.find(item => item.targetKey == key)?.replacementKeyCode || null;\r\n    }\r\n\r\n    /**\r\n     * Handle the touch events\r\n     * @private\r\n     * @param event\r\n     * @todo THIS NEEDS TO BE SIMPLIFIED AND EITHER MOVED TO A DIFFERENT CLASS OR BECOME PART OF A SUPERCLASS\r\n     */\r\n    private handleTouchEvent(event:TouchEvent) {\r\n        if (event.type == 'touchstart') {\r\n            for (let i:number = 0; i < event.changedTouches.length; i++) {\r\n                let startingTouch = event.changedTouches[i]\r\n                if (!this.dPadMode && startingTouch.clientX < 200 ) {\r\n                    this.setOrigin(startingTouch)\r\n                }  else {\r\n                    for (let j:number = 0; j < this.buttons.length; j++) {\r\n\r\n                        if (this.dPadMode) {\r\n\r\n                            let xPct = (startingTouch.clientX - this.dPadBounds.left) / this.dPadBounds.width * 100;\r\n                            let yPct = (startingTouch.clientY - this.dPadBounds.top) / this.dPadBounds.height * 100;\r\n\r\n                            if (xPct >= 0 && xPct <= 100 && yPct > 0 && yPct <= 100) {\r\n                                if (yPct < 33) {\r\n                                    if (xPct > 33 && xPct < 67) {\r\n                                        this.ci.simulateKeyPress(this.directionMapping['up'])\r\n                                    }\r\n                                } else if (yPct < 67) {\r\n                                    if (xPct < 33) {\r\n                                        this.ci.simulateKeyPress(this.directionMapping['left'])\r\n                                    } else if (xPct > 67) {\r\n                                        this.ci.simulateKeyPress(this.directionMapping['right'])\r\n                                    }\r\n                                } else {\r\n                                    if (xPct > 33 && xPct < 67) {\r\n                                        this.ci.simulateKeyPress(this.directionMapping['down'])\r\n                                    }\r\n                                }\r\n                                continue;\r\n                            }\r\n\r\n                        }\r\n\r\n                        let mapping:ButtonMapping = this.buttons[j]\r\n                        let rect = mapping.element.getBoundingClientRect()\r\n                        let x1 = rect.x, x2 = rect.x + rect.width, y1 = rect.y, y2 = rect.y + rect.height;\r\n                        if (startingTouch.clientX > x1 && startingTouch.clientX < x2 && startingTouch.clientY > y1 && startingTouch.clientY < y2) {\r\n                            this.ci.simulateKeyPress(mapping.asciiCode, true)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else if (this.dPadMode == false && event.type == 'touchmove') {\r\n            for (let i:number = 0; i < event.changedTouches.length; i++) {\r\n                let movingTouch:Touch = event.changedTouches[i]\r\n                if (movingTouch.clientX < 200) {\r\n\r\n                    let control = []\r\n                    let dx = movingTouch.clientX - this.origin.x;\r\n                    let dy = movingTouch.clientY - this.origin.y;\r\n                    if (dx === 0 && dy === 0 || isNaN(dx) || isNaN(dy)) return\r\n\r\n                    let rangeInner:number = dy * 0.38;\r\n                    let rangeOuter:number = dy * 2.61;\r\n\r\n                    if (this.directions.directions === 8) {\r\n                        if (dx < -Math.abs(rangeOuter)) {\r\n                            control = ['left']\r\n                        } else if (dy < 0 && dx < rangeInner) {\r\n                            control = ['up','left']\r\n                        } else if (dy < 0 && dx < Math.abs(rangeInner)) {\r\n                            control = ['up']\r\n                        } else if (dy < 0 && dx < -rangeOuter) {\r\n                            control = ['up','right']\r\n                        } else if (dx > Math.abs(rangeOuter)) {\r\n                            control = ['right']\r\n                        } else if (dy > 0 && dx < -Math.abs(rangeInner)) {\r\n                            control = ['down','right']\r\n                        } else if (dy > 0 && dx < rangeInner) {\r\n                            control = ['down']\r\n                        } else if (dy > 0 && dx < dy * rangeOuter) {\r\n                            control = ['down','left']\r\n                        } else {\r\n                            console.error (\"Not a known angle / direction\")\r\n                        }\r\n                    } else if (this.directions.directions === 4) {\r\n                        if (dx < 0 && dx < -Math.abs(dy)) {\r\n                            control = ['left']\r\n                        } else if (dy < 0 && dx < -dy) {\r\n                            control = ['up']\r\n                        } else if (dx > 0 && dx > Math.abs(dy)) {\r\n                            control = ['right']\r\n                        } else if (dy > 0 && dx < dy) {\r\n                            control = ['down']\r\n                        } else {\r\n                            console.error (\"Not a known angle / direction\")\r\n                        }\r\n                    } else if (this.directions.directions === 2) {\r\n                        if (dx < 0) {\r\n                            control = ['left']\r\n                        } else if (dx > 0) {\r\n                            control = ['right']\r\n                        } else {\r\n                            console.error (\"Not a known angle / direction\")\r\n                        }\r\n                    } else {\r\n                        console.error(\"Only 2, 4 or 8 directions allowed\")\r\n                    }\r\n\r\n                    this.processDirectionChange(this.lastDirection, control)\r\n                    this.lastDirection = control;\r\n                }\r\n\r\n            }\r\n        } else if (event.type == 'touchend') {\r\n            for (let i = 0; i < event.changedTouches.length; i++) {\r\n                let endingTouch:Touch = event.changedTouches[i];\r\n                if (endingTouch.identifier === this.origin.id) {\r\n                    this.origin.x = null;\r\n                    this.origin.y = null;\r\n                    this.origin.id = null;\r\n                    if (this.lastDirection.length > 0) {\r\n                        this.processDirectionChange(this.lastDirection, [])\r\n                    }\r\n                    this.lastDirection = [];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Looks for differences between the two arrays and turns on or off new directions\r\n     * eg: The examples in the parameters below will send a key event to the emulator with keyup for left\r\n     * @param was the array from the previous iteration (eg: ['left', 'up'])\r\n     * @param is the array from the previous iteration (eg: ['up'])\r\n     */\r\n    private processDirectionChange = (was, is) => {\r\n\r\n        let turnOff = was.filter(w => is.indexOf(w) === -1)\r\n        let turnOn = is.filter(i => was.indexOf(i) === -1)\r\n        turnOff.forEach((direction) => {\r\n            this.ci.simulateKeyEvent(this.getDirectionAscii(direction), false);\r\n        });\r\n        turnOn.forEach((direction) => {\r\n            this.ci.simulateKeyEvent(this.getDirectionAscii(direction), true)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the ascii code for the corresponding arrow key\r\n     * @param direction\r\n     * @private\r\n     */\r\n    private getDirectionAscii(direction:string):number {\r\n        return this.directionMapping[direction];\r\n    }\r\n\r\n    /**\r\n     * Convert radians tp degrees\r\n     * @param rad the angle in radians\r\n     */\r\n    private radToDeg = (rad) => {\r\n        return Math.round(rad * 180 / Math.PI);\r\n    }\r\n\r\n    /**\r\n     * Set the starting point (touch)\r\n     * @param touchEvent the touch event where the movement started\r\n     * @private\r\n     */\r\n    private setOrigin(touchEvent:Touch) {\r\n        this.origin = {x:touchEvent.clientX, y:touchEvent.clientY, id:touchEvent.identifier}\r\n    }\r\n\r\n    /**\r\n     * When a user clicks away, unload the WASM code\r\n     * @private\r\n     */\r\n    private unload() {\r\n        this.dosRef.exit();\r\n    }\r\n\r\n}\r\n"],"names":["dosRef","rootElement","emulators","forceKeyPress","this","x","y","id","up","down","left","right","directionAscii","_this","directionMapping","was","is","turnOff","filter","w","indexOf","turnOn","i","forEach","direction","ci","simulateKeyEvent","getDirectionAscii","rad","Math","round","PI","DosGame","Promise","resolve","canvas","cycles","options","wdosboxUrl","onprogress","log","ready","fs","main","extract","zipFile","then","execCmdArray","window","focus","addEventListener","unload","gameBundle","pathPrefix","run","console","dosboxConf","push","createFile","targetKey","replacementKeyCode","keysToReplace","length","addKeyEventListeners","directions","buttons","addTouchEventListeners","dPadElem","dPadBounds","getBoundingClientRect","dPadMode","buttonMapping","asciiCode","wait","reject","setTimeout","simulateKeyPress","callback","delay","addPixelListener","interval","setInterval","doIntervalPoll","bind","pixelListeners","lastColor","undefined","canvasContext","getContext","generalPixelCallback","clearInterval","toDataURL","colors","pl","pixelColor","getImageData","colorValue","getHexValue","data","number","toString","slice","handleKeyEvent","touchEventListenersAdded","document","handleTouchEvent","event","type","metaKey","keyCode","findReplacementKeyCode","key","keysDown","includes","splice","stopImmediatePropagation","stopPropagation","preventDefault","find","item","changedTouches","startingTouch","clientX","setOrigin","j","xPct","width","yPct","clientY","top","height","mapping","rect","element","x1","x2","y1","y2","movingTouch","control","dx","origin","dy","isNaN","rangeInner","rangeOuter","abs","error","processDirectionChange","lastDirection","identifier","touchEvent","exit","navigator","maxTouchPoints","msMaxTouchPoints"],"mappings":"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"}