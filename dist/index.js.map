{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["interface GameOptions {\n    cycles: number\n    zipFile: string\n    execCmdArray: string[]\n}\n\ninterface KeyMapping {\n    targetKey: string\n    replacementKeyCode: number\n}\n\ninterface Directions {\n    directions: number\n}\n\ninterface ButtonMapping {\n    element:HTMLElement\n    asciiCode:number\n}\n\ninterface Origin {\n    x: number\n    y: number\n    id: number\n}\n\ninterface PixelListener {\n    x: number\n    y: number\n    callback: (string) => void\n}\n\n/**\n * DosGame. Object and helper methods to make it easier to run DOS games in a browser using DOSBox\n * @Author Mark van Wyk\n * @copyright Emerge Gaming @copy; 2021\n */\nexport class DosGame {\n\n    private dosRef: any;\n    private options: GameOptions\n    private canvas: HTMLCanvasElement\n    private ci: any\n    private keysToReplace:KeyMapping[] = []\n    private directions:Directions\n    private buttons:ButtonMapping[] = []\n    private origin:Origin = {x:null, y:null, id:null}\n    private lastDirection:string[] = []\n    private canvasContext:CanvasRenderingContext2D\n    private interval:number\n    private pixelListener:PixelListener\n    private lastPixelValue:string\n\n    /**\n     * Create a new DosGame object.\n     * that this object requires the JSDos script to be loaded by the page.\n     *\n     * eg: <script src=\"/dosbox/js-dos.js\"></script>\n     *\n     * @param dosRef a reference to window.DOS created by the included JavaScript file\n     * @param options {cycles:number, zipFile:string, execCmd:string}\n     * @param canvas reference to the HTMLCanvasElement DOSBox is being rendered on\n     *\n     * @see https://js-dos.com/\n     */\n    constructor(dosRef:any, options:GameOptions, canvas:HTMLCanvasElement) {\n        this.dosRef = dosRef\n        this.options = options\n        this.canvas = canvas\n    }\n\n    public start():Promise<any> {\n        return new Promise((resolve) => {\n            this.options.execCmdArray.push('-conf');\n            this.options.execCmdArray.push('dosbox.conf')\n            console.log (this.options.execCmdArray);\n            this.dosRef(this.canvas, {\n                cycles: this.options.cycles,\n                wdosboxUrl: '/dosbox/wdosbox.js',\n                onprogress: () => {},\n                log: () => {}\n            }).ready((fs, main) => {\n                fs.extract(this.options.zipFile).then(() => {\n                    fs.createFile(\"dosbox.conf\", `\n[joystick]\njoysticktype=none\n                    `);\n                    main(this.options.execCmdArray).then((ci) => {\n                        this.ci = ci\n                        resolve(ci)\n                        window.focus();\n                        window.addEventListener('unload', this.unload)\n                    })\n                })\n            })\n        })\n    }\n\n    /**\n     * Capture a key (hopefully before the emulator gets it and replace it with a different key\n     * @param targetKey the event.key (not the ascii code) we're looking for.\n     * @param replacementKeyCode the ASCII key to send to DOSBox\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n     */\n    public overrideKey(targetKey:string, replacementKeyCode:number):void {\n        if (this.keysToReplace.length === 0) this.addKeyEventListeners()\n        this.keysToReplace.push({targetKey:targetKey, replacementKeyCode:replacementKeyCode})\n    }\n\n    /**\n     * Convert touch dragging to\n     * @param directions\n     */\n    public mapTouchToArrowKeys(directions:Directions):void {\n        this.directions = directions\n        if (this.buttons.length == 0) {\n            this.addTouchEventListeners()\n        }\n    }\n\n    /**\n     * Map an on-screen button to a keypress.\n     * @param buttonMapping the keyCode and asciiCode mapping.\n     */\n    public mapButtonToKey(buttonMapping:ButtonMapping):void {\n        this.buttons.push(buttonMapping)\n        if (!this.directions) {\n            this.addTouchEventListeners()\n        }\n    }\n\n    /**\n     * Automatically press a key after a certain period of time\n     * @param asciiCode the asciiCode of the key to press\n     * @param wait the wait period in milliseconds\n     */\n    public autoKeyPress(asciiCode:number, wait:number = 0):Promise<any> {\n        return new Promise<unknown>((resolve, reject) =>\n            setTimeout (() => {\n                this.ci.simulateKeyPress(asciiCode);\n                if (wait > 0 && resolve) resolve(null);\n            }, wait)\n        )\n    }\n\n    /**\n     * Give the x y coordinate of a pixel with a callback to be called when the colour changes\n     * @param x coord of pixel\n     * @param y coord of pixel\n     * @param callback\n     * @param delay the number of ms to wait\n     * @todo: This should really be called addPixelListener (i.e. more than one)\n     */\n    public setPixelListener(x:number, y:number, callback, delay:number = 1000) {\n        window.clearInterval(this.interval);\n        this.pixelListener = {x:x, y:y, callback:callback}\n        this.canvasContext = this.canvas.getContext('2d');\n        this.interval = window.setInterval(this.doIntervalPoll.bind(this), delay)\n    }\n\n    public stopPixelListener() {\n        window.clearInterval(this.interval);\n    }\n\n    public consoleScreenshots() {\n        setInterval(() => {\n            console.log (this.canvas.toDataURL('img/png'));\n        }, 1500)\n\n    }\n\n    public static isTouch = () => {\n        return (('ontouchstart' in window) ||\n            (navigator.maxTouchPoints > 0) ||\n            (navigator.msMaxTouchPoints > 0));\n    }\n\n    /***** P R I V A T E   M E T H O D S *****/\n\n    private doIntervalPoll() {\n        let pixelColor:ImageData = this.canvasContext.getImageData(this.pixelListener.x, this.pixelListener.y, 1, 1);\n        let colorValue:string = '#' + DosGame.getHexValue(pixelColor.data[0]) + DosGame.getHexValue(pixelColor.data[1]) + DosGame.getHexValue(pixelColor.data[2]);\n        if (colorValue != this.lastPixelValue) {\n            this.pixelListener.callback(colorValue);\n            this.lastPixelValue = colorValue;\n        }\n    }\n\n    private static getHexValue(number:number):string {\n        return (\"00\" + number.toString(16)).slice(-2)\n    }\n\n    /**\n     * Create key event listeners\n     * @private\n     */\n    private addKeyEventListeners() {\n        window.addEventListener('keyup', this.handleKeyEvent.bind(this))\n        window.addEventListener('keydown', this.handleKeyEvent.bind(this))\n    }\n\n    /**\n     * Create touch listeners\n     */\n    private addTouchEventListeners() {\n        document.addEventListener('touchstart', this.handleTouchEvent.bind(this))\n        document.addEventListener('touchend', this.handleTouchEvent.bind(this))\n        document.addEventListener('touchmove', this.handleTouchEvent.bind(this))\n    }\n\n    /**\n     * When a key is pressed (keydown) or released (keyup), check to see if it's a mapped key and rather send the\n     * preferred key to DosBox.\n     * @param event KeyboardEvent of the pressed or released key\n     * @private\n     */\n    private handleKeyEvent(event:KeyboardEvent) {\n        if (event.key) {\n            for (let i: number = 0; i < this.keysToReplace.length; i++) {\n                let keyMapping:KeyMapping = this.keysToReplace[i]\n                if (event.key == keyMapping.targetKey) {\n                    event.preventDefault()\n                    event.stopImmediatePropagation()\n                    if (keyMapping.replacementKeyCode)\n                        this.ci.simulateKeyEvent(keyMapping.replacementKeyCode, event.type == 'keydown');\n                }\n            }\n        }\n    }\n\n    /**\n     * Handle the touch events\n     * @private\n     * @param event\n     * @todo THIS NEEDS TO BE SIMPLIFIED AND EITHER MOVED TO A DIFFERENT CLASS OR BECOME PART OF A SUPERCLASS\n     */\n    private handleTouchEvent(event:TouchEvent) {\n        if (event.type == 'touchstart') {\n            for (let i:number = 0; i < event.changedTouches.length; i++) {\n                let startingTouch = event.changedTouches[i]\n                if (startingTouch.clientX < 200) {\n                    this.setOrigin(startingTouch)\n                }  else {\n                    for (let j:number = 0; j < this.buttons.length; j++) {\n                        let mapping:ButtonMapping = this.buttons[j]\n                        let rect = mapping.element.getBoundingClientRect()\n                        let x1 = rect.x, x2 = rect.x + rect.width, y1 = rect.y, y2 = rect.y + rect.height;\n                        if (startingTouch.clientX > x1 && startingTouch.clientX < x2 && startingTouch.clientY > y1 && startingTouch.clientY < y2) {\n                            this.ci.simulateKeyPress(mapping.asciiCode, true)\n                        }\n                    }\n                }\n            }\n\n        } else if (event.type == 'touchmove') {\n            for (let i:number = 0; i < event.changedTouches.length; i++) {\n                let movingTouch:Touch = event.changedTouches[i]\n                if (movingTouch.clientX < 200) {\n\n                    let control = []\n                    let dx = movingTouch.clientX - this.origin.x;\n                    let dy = movingTouch.clientY - this.origin.y;\n                    if (dx === 0 && dy === 0 || isNaN(dx) || isNaN(dy)) return\n\n                    let rangeInner:number = dy * 0.38;\n                    let rangeOuter:number = dy * 2.61;\n\n                    if (this.directions.directions === 8) {\n                        if (dx < -Math.abs(rangeOuter)) {\n                            control = ['left']\n                        } else if (dy < 0 && dx < rangeInner) {\n                            control = ['up','left']\n                        } else if (dy < 0 && dx < Math.abs(rangeInner)) {\n                            control = ['up']\n                        } else if (dy < 0 && dx < -rangeOuter) {\n                            control = ['up','right']\n                        } else if (dx > Math.abs(rangeOuter)) {\n                            control = ['right']\n                        } else if (dy > 0 && dx < -Math.abs(rangeInner)) {\n                            control = ['down','right']\n                        } else if (dy > 0 && dx < rangeInner) {\n                            control = ['down']\n                        } else if (dy > 0 && dx < dy * rangeOuter) {\n                            control = ['down','left']\n                        } else {\n                            console.log (\"Not a known angle / direction\")\n                        }\n                    } else if (this.directions.directions === 4) {\n                        if (dx < 0 && dx < -Math.abs(dy)) {\n                            control = ['left']\n                        } else if (dy < 0 && dx < -dy) {\n                            control = ['up']\n                        } else if (dx > 0 && dx > Math.abs(dy)) {\n                            control = ['right']\n                        } else if (dy > 0 && dx < dy) {\n                            control = ['down']\n                        } else {\n                            console.log (\"Not a known angle / direction\")\n                        }\n                    } else if (this.directions.directions === 2) {\n                        if (dx < 0) {\n                            control = ['left']\n                        } else if (dx > 0) {\n                            control = ['right']\n                        } else {\n                            console.log (\"Not a known angle / direction\")\n                        }\n                    } else {\n                        console.error(\"Only 2, 4 or 8 directions allowed\")\n                    }\n\n                    this.processDirectionChange(this.lastDirection, control)\n                    this.lastDirection = control;\n                }\n\n            }\n        } else if (event.type == 'touchend') {\n            for (let i = 0; i < event.changedTouches.length; i++) {\n                let endingTouch:Touch = event.changedTouches[i];\n                if (endingTouch.identifier === this.origin.id) {\n                    this.origin.x = null;\n                    this.origin.y = null;\n                    this.origin.id = null;\n                    if (this.lastDirection.length > 0) {\n                        this.processDirectionChange(this.lastDirection, [])\n                    }\n                    this.lastDirection = [];\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks for differences between the two arrays and turns on or off new directions\n     * eg: The examples in the parameters below will send a key event to the emulator with keyup for left\n     * @param was the array from the previous iteration (eg: ['left', 'up'])\n     * @param is the array from the previous iteration (eg: ['up'])\n     */\n    private processDirectionChange = (was, is) => {\n\n        let turnOff = was.filter(w => is.indexOf(w) === -1)\n        let turnOn = is.filter(i => was.indexOf(i) === -1)\n        turnOff.forEach((direction) => {\n            console.log (direction + \" off\")\n            this.ci.simulateKeyEvent(DosGame.getDirectionAscii(direction), false);\n        });\n        turnOn.forEach((direction) => {\n            console.log (direction + \" on\")\n            this.ci.simulateKeyEvent(DosGame.getDirectionAscii(direction), true)\n        });\n    }\n\n    /**\n     * Returns the ascii code for the corresponding arrow key\n     * @param direction\n     * @private\n     */\n    private static getDirectionAscii(direction:string):number {\n        switch (direction) {\n            case 'up'  : return 38;\n            case 'down': return 40;\n            case 'left': return 37;\n            case 'right': return 39;\n        }\n    }\n\n    /**\n     * Convert radians tp degrees\n     * @param rad the angle in radians\n     */\n    private radToDeg = (rad) => {\n        return Math.round(rad * 180 / Math.PI);\n    }\n\n    /**\n     * Set the starting point (touch)\n     * @param touchEvent the touch event where the movement started\n     * @private\n     */\n    private setOrigin(touchEvent:Touch) {\n        this.origin = {x:touchEvent.clientX, y:touchEvent.clientY, id:touchEvent.identifier}\n    }\n\n    /**\n     * When a user clicks away, unload the WASM code\n     * @private\n     */\n    private unload() {\n        this.ci.exit()\n    }\n\n}\n"],"names":["dosRef","options","canvas","this","x","y","id","was","is","turnOff","filter","w","indexOf","turnOn","i","forEach","direction","console","log","_this","ci","simulateKeyEvent","DosGame","getDirectionAscii","rad","Math","round","PI","Promise","resolve","execCmdArray","push","cycles","wdosboxUrl","onprogress","ready","fs","main","extract","zipFile","then","createFile","window","focus","addEventListener","unload","targetKey","replacementKeyCode","keysToReplace","length","addKeyEventListeners","directions","buttons","addTouchEventListeners","buttonMapping","asciiCode","wait","reject","setTimeout","simulateKeyPress","callback","delay","clearInterval","interval","pixelListener","canvasContext","getContext","setInterval","doIntervalPoll","bind","toDataURL","pixelColor","getImageData","colorValue","getHexValue","data","lastPixelValue","number","toString","slice","handleKeyEvent","document","handleTouchEvent","event","key","keyMapping","preventDefault","stopImmediatePropagation","type","changedTouches","startingTouch","clientX","setOrigin","j","mapping","rect","element","getBoundingClientRect","x1","x2","width","y1","y2","height","clientY","movingTouch","control","dx","origin","dy","isNaN","rangeInner","rangeOuter","abs","error","processDirectionChange","lastDirection","identifier","touchEvent","exit","navigator","maxTouchPoints","msMaxTouchPoints"],"mappings":"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"}