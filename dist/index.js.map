{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["interface GameOptions {\n    cycles: number\n    zipFile: string\n    execCmdArray: string[]\n}\n\ninterface KeyMapping {\n    targetKey: string\n    replacementKeyCode: number\n}\n\ninterface Directions {\n    directions: number\n}\n\ninterface ButtonMapping {\n    element:HTMLElement\n    asciiCode:number\n}\n\ninterface Origin {\n    x: number\n    y: number\n    id: number\n}\n\ninterface PixelListener {\n    x: number\n    y: number\n    callback: (string) => void\n    lastColor: string\n}\n\ninterface DirectionMapping {\n    direction:string\n    asciiMapping:number\n}\n\n/**\n * DosGame. Object and helper methods to make it easier to run DOS games in a browser using DOSBox\n * @Author Mark van Wyk\n * @copyright Emerge Gaming @copy; 2021\n */\nexport class DosGame {\n\n    private dosRef: any;\n    private options: GameOptions\n    private canvas: HTMLCanvasElement\n    private ci: any\n    private keysToReplace:KeyMapping[] = []\n    private directions:Directions\n    private buttons:ButtonMapping[] = []\n    private origin:Origin = {x:null, y:null, id:null}\n    private lastDirection:string[] = []\n    private canvasContext:CanvasRenderingContext2D\n    private interval:number\n    private pixelListeners:PixelListener[] = []\n    private keysDown:string[] = []\n    private readonly forceKeyPress:boolean;\n    private generalPixelCallback: (colours:string[]) => void;\n    private dPadMode:boolean = false;\n    private dPadBounds:DOMRect;\n    private touchEventListenersAdded:boolean = false;\n\n    private directionMapping:object = {\n        'up': 38,\n        'down':40,\n        'left':37,\n        'right':39\n    };\n\n\n    /**\n     * Create a new DosGame object.\n     * that this object requires the JSDos script to be loaded by the page.\n     *\n     * eg: <script src=\"/dosbox/js-dos.js\"></script>\n     *\n     * @param dosRef a reference to window.DOS created by the included JavaScript file\n     * @param options {cycles:number, zipFile:string, execCmd:string[]}\n     * @param canvas reference to the HTMLCanvasElement DOSBox is being rendered on\n     * @param forceKeyPress force simulateKeyPress instead of simulateKeyEvent\n     * @see https://js-dos.com/\n     */\n    constructor(dosRef:any, options:GameOptions, canvas:HTMLCanvasElement, forceKeyPress:boolean = false) {\n        this.dosRef = dosRef\n        this.options = options\n        this.canvas = canvas\n        this.forceKeyPress = forceKeyPress;\n    }\n\n\n    public start():Promise<any> {\n        return new Promise((resolve) => {\n            this.dosRef(this.canvas, {\n                cycles: this.options.cycles,\n                wdosboxUrl: '/dosbox/wdosbox.js',\n                onprogress: () => {},\n                log: () => {}\n            }).ready((fs, main) => {\n                fs.extract(this.options.zipFile).then(() => {\n                    main(this.options.execCmdArray).then((ci) => {\n                        this.ci = ci\n                        resolve(ci)\n                        window.focus();\n                        window.addEventListener('unload', this.unload)\n                    })\n                })\n            })\n        })\n    }\n\n    public getCommandInterface():object {\n        return this.ci;\n    }\n\n\n    public startWithConf(dosboxConf):Promise<any> {\n        return new Promise((resolve) => {\n            this.options.execCmdArray.push('-conf');\n            this.options.execCmdArray.push('dosbox.conf')\n            this.dosRef(this.canvas, {\n                wdosboxUrl: '/dosbox/wdosbox.js',\n            }).ready((fs, main) => {\n                fs.extract(this.options.zipFile).then(() => {\n                    fs.createFile(\"dosbox.conf\", dosboxConf);\n                    main(this.options.execCmdArray).then((ci) => {\n                        this.ci = ci\n                        resolve(ci)\n                        window.focus();\n                        window.addEventListener('unload', this.unload)\n                    })\n                })\n            })\n        })\n    }\n\n    /**\n     * Capture a key (hopefully before the emulator gets it and replace it with a different key\n     * @param targetKey the event.key (not the ascii code) we're looking for.\n     * @param replacementKeyCode the ASCII key to send to DOSBox\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n     */\n    public overrideKey(targetKey:string, replacementKeyCode:number):void {\n        if (this.keysToReplace.length === 0) this.addKeyEventListeners()\n        this.keysToReplace.push({targetKey:targetKey, replacementKeyCode:replacementKeyCode})\n    }\n\n    /**\n     * Convert touch dragging to direction keys\n     * @param directions can be 8 (including diagonals), 4 (up, down, left right) or 2 (left or right)\n     *\n     */\n    public mapTouchToArrowKeys(directions:Directions):void {\n        this.directions = directions\n        if (this.buttons.length == 0) {\n            this.addTouchEventListeners()\n        }\n    }\n\n    /**\n     * Use the D-Pad instead of the touch dragging (joystick)\n     * @param dPadElem the HTMLElement of the bounding (div) of the D-Pad container. Used to assess where the finder is.\n     */\n    public mapDPadToArrowKeys(dPadElem):void {\n\n        this.dPadBounds = dPadElem.getBoundingClientRect();this.dPadMode = true;\n        this.addTouchEventListeners();\n    }\n\n    /**\n     * Map an on-screen button to a keypress.\n     * @param buttonMapping the keyCode and asciiCode mapping.\n     */\n    public mapButtonToKey(buttonMapping:ButtonMapping):void {\n        this.buttons.push(buttonMapping)\n        if (!this.directions) {\n            this.addTouchEventListeners()\n        }\n    }\n\n    /**\n     * Automatically press a key after a certain period of time\n     * @param asciiCode the asciiCode of the key to press\n     * @param wait the wait period in milliseconds\n     */\n    public autoKeyPress(asciiCode:number, wait:number = 0):Promise<any> {\n        return new Promise<unknown>((resolve, reject) =>\n            setTimeout (() => {\n                this.ci.simulateKeyPress(asciiCode);\n                if (wait > 0 && resolve) resolve(null);\n            }, wait)\n        )\n    }\n\n    /**\n     * Give the x y coordinate of a pixel with a callback to be called when the colour changes\n     * @param x coord of pixel\n     * @param y coord of pixel\n     * @param callback\n     * @param delay the number of ms to wait\n     * @todo: This should really be called addPixelListener (i.e. more than one)\n     * @deprecated use addPixelListener\n     */\n    public setPixelListener(x:number, y:number, callback, delay:number = 1000) {\n        this.addPixelListener(x, y, callback, delay);\n    }\n\n    /**\n     * Give the x y coordinate of a pixel with a callback to be called when the colour changes\n     * @param x coord of x pixel\n     * @param y coord of y pixel\n     * @param callback to callback every interval with the pixel colour.\n     * @param delay the number of ms between callback intervals\n     */\n    public addPixelListener(x:number, y:number, callback, delay:number = 1000) {\n        if (!this.interval) this.interval = window.setInterval(this.doIntervalPoll.bind(this), delay)\n        this.pixelListeners.push({x:x, y:y, callback:callback, lastColor:undefined})\n\n        if (!this.canvasContext) this.canvasContext = this.canvas.getContext('2d');\n    }\n\n    public setGeneralPixelCallback(callback:(colours:string[]) => void) {\n        this.generalPixelCallback = callback;\n    }\n\n    public stopPixelListener() {\n        window.clearInterval(this.interval);\n    }\n\n    public consoleScreenshots() {\n        setInterval(() => {\n            console.log (this.canvas.toDataURL('img/png'));\n        }, 1500)\n\n    }\n\n    public static isTouch = () => {\n        return (('ontouchstart' in window) ||\n            (navigator.maxTouchPoints > 0) ||\n            (navigator.msMaxTouchPoints > 0));\n    }\n\n    public overrideDirectionAscii = (directionAscii:object) => {\n        this.directionMapping = directionAscii;\n    }\n\n    /***** P R I V A T E   M E T H O D S *****/\n\n    private doIntervalPoll() {\n\n        let colors:string[] = []\n\n        this.pixelListeners.forEach((pl) => {\n            let pixelColor:ImageData = this.canvasContext.getImageData(pl.x, pl.y, 1, 1);\n            let colorValue:string = '#' + DosGame.getHexValue(pixelColor.data[0]) + DosGame.getHexValue(pixelColor.data[1]) + DosGame.getHexValue(pixelColor.data[2]);\n            colors.push(colorValue)\n            if (colorValue != pl.lastColor) {\n                pl.callback(colorValue);\n                pl.lastColor = colorValue;\n            }\n        });\n\n        if (this.generalPixelCallback) this.generalPixelCallback(colors);\n    }\n\n    private static getHexValue(number:number):string {\n        return (\"00\" + number.toString(16)).slice(-2)\n    }\n\n    /**\n     * Create key event listeners\n     * @private\n     */\n    private addKeyEventListeners() {\n        window.addEventListener('keyup', this.handleKeyEvent.bind(this))\n        window.addEventListener('keydown', this.handleKeyEvent.bind(this))\n    }\n\n    /**\n     * Create touch listeners\n     */\n    private addTouchEventListeners() {\n        if (!this.touchEventListenersAdded) {\n            document.addEventListener('touchstart', this.handleTouchEvent.bind(this))\n            document.addEventListener('touchend', this.handleTouchEvent.bind(this))\n            document.addEventListener('touchmove', this.handleTouchEvent.bind(this))\n            this.touchEventListenersAdded = true;\n        }\n    }\n\n    /**\n     * When a key is pressed (keydown) or released (keyup), check to see if it's a mapped key and rather send the\n     * preferred key to DosBox.\n     * @param event KeyboardEvent of the pressed or released key\n     * @private\n     */\n    private handleKeyEvent(event:KeyboardEvent) {\n\n        if ((event.type === 'keydown' || event.type === 'keyup') && event.metaKey == false) {\n            let keyCode = this.findReplacementKeyCode(event.key);\n            if (keyCode) {\n                if (event.type === 'keydown' && !this.keysDown.includes(event.key)) {\n                    this.forceKeyPress ? this.ci.simulateKeyPress(keyCode, true) : this.ci.simulateKeyEvent(keyCode, true)\n                    this.keysDown.push(event.key)\n                }\n\n                if (event.type === 'keyup' && this.keysDown.includes(event.key)) {\n                    this.forceKeyPress ? this.ci.simulateKeyPress(keyCode, false) : this.ci.simulateKeyEvent(keyCode, false)\n                    this.keysDown.splice(this.keysDown.indexOf(event.key),1);\n                }\n\n                event.stopImmediatePropagation();\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        }\n    }\n\n    private findReplacementKeyCode(key:string) {\n        return this.keysToReplace.find(item => item.targetKey == key)?.replacementKeyCode || null;\n    }\n\n    /**\n     * Handle the touch events\n     * @private\n     * @param event\n     * @todo THIS NEEDS TO BE SIMPLIFIED AND EITHER MOVED TO A DIFFERENT CLASS OR BECOME PART OF A SUPERCLASS\n     */\n    private handleTouchEvent(event:TouchEvent) {\n        if (event.type == 'touchstart') {\n            for (let i:number = 0; i < event.changedTouches.length; i++) {\n                let startingTouch = event.changedTouches[i]\n                if (!this.dPadMode && startingTouch.clientX < 200 ) {\n                    this.setOrigin(startingTouch)\n                }  else {\n                    for (let j:number = 0; j < this.buttons.length; j++) {\n\n                        if (this.dPadMode) {\n\n                            let xPct = (startingTouch.clientX - this.dPadBounds.left) / this.dPadBounds.width * 100;\n                            let yPct = (startingTouch.clientY - this.dPadBounds.top) / this.dPadBounds.height * 100;\n\n                            if (xPct >= 0 && xPct <= 100 && yPct > 0 && yPct <= 100) {\n                                if (yPct < 33) {\n                                    if (xPct > 33 && xPct < 67) {\n                                        this.ci.simulateKeyPress(this.directionMapping['up'])\n                                    }\n                                } else if (yPct < 67) {\n                                    if (xPct < 33) {\n                                        this.ci.simulateKeyPress(this.directionMapping['left'])\n                                    } else if (xPct > 67) {\n                                        this.ci.simulateKeyPress(this.directionMapping['right'])\n                                    }\n                                } else {\n                                    if (xPct > 33 && xPct < 67) {\n                                        this.ci.simulateKeyPress(this.directionMapping['down'])\n                                    }\n                                }\n                                continue;\n                            }\n\n                        }\n\n                        let mapping:ButtonMapping = this.buttons[j]\n                        let rect = mapping.element.getBoundingClientRect()\n                        let x1 = rect.x, x2 = rect.x + rect.width, y1 = rect.y, y2 = rect.y + rect.height;\n                        if (startingTouch.clientX > x1 && startingTouch.clientX < x2 && startingTouch.clientY > y1 && startingTouch.clientY < y2) {\n                            this.ci.simulateKeyPress(mapping.asciiCode, true)\n                        }\n                    }\n                }\n            }\n\n        } else if (this.dPadMode == false && event.type == 'touchmove') {\n            for (let i:number = 0; i < event.changedTouches.length; i++) {\n                let movingTouch:Touch = event.changedTouches[i]\n                if (movingTouch.clientX < 200) {\n\n                    let control = []\n                    let dx = movingTouch.clientX - this.origin.x;\n                    let dy = movingTouch.clientY - this.origin.y;\n                    if (dx === 0 && dy === 0 || isNaN(dx) || isNaN(dy)) return\n\n                    let rangeInner:number = dy * 0.38;\n                    let rangeOuter:number = dy * 2.61;\n\n                    if (this.directions.directions === 8) {\n                        if (dx < -Math.abs(rangeOuter)) {\n                            control = ['left']\n                        } else if (dy < 0 && dx < rangeInner) {\n                            control = ['up','left']\n                        } else if (dy < 0 && dx < Math.abs(rangeInner)) {\n                            control = ['up']\n                        } else if (dy < 0 && dx < -rangeOuter) {\n                            control = ['up','right']\n                        } else if (dx > Math.abs(rangeOuter)) {\n                            control = ['right']\n                        } else if (dy > 0 && dx < -Math.abs(rangeInner)) {\n                            control = ['down','left']\n                        } else if (dy > 0 && dx < rangeInner) {\n                            control = ['down']\n                        } else if (dy > 0 && dx < dy * rangeOuter) {\n                            control = ['down','right']\n                        } else {\n                            console.error (\"Not a known angle / direction\")\n                        }\n                    } else if (this.directions.directions === 4) {\n                        if (dx < 0 && dx < -Math.abs(dy)) {\n                            control = ['left']\n                        } else if (dy < 0 && dx < -dy) {\n                            control = ['up']\n                        } else if (dx > 0 && dx > Math.abs(dy)) {\n                            control = ['right']\n                        } else if (dy > 0 && dx < dy) {\n                            control = ['down']\n                        } else {\n                            console.error (\"Not a known angle / direction\")\n                        }\n                    } else if (this.directions.directions === 2) {\n                        if (dx < 0) {\n                            control = ['left']\n                        } else if (dx > 0) {\n                            control = ['right']\n                        } else {\n                            console.error (\"Not a known angle / direction\")\n                        }\n                    } else {\n                        console.error(\"Only 2, 4 or 8 directions allowed\")\n                    }\n\n                    this.processDirectionChange(this.lastDirection, control)\n                    this.lastDirection = control;\n                }\n\n            }\n        } else if (event.type == 'touchend') {\n            for (let i = 0; i < event.changedTouches.length; i++) {\n                let endingTouch:Touch = event.changedTouches[i];\n                if (endingTouch.identifier === this.origin.id) {\n                    this.origin.x = null;\n                    this.origin.y = null;\n                    this.origin.id = null;\n                    if (this.lastDirection.length > 0) {\n                        this.processDirectionChange(this.lastDirection, [])\n                    }\n                    this.lastDirection = [];\n                }\n            }\n        }\n    }\n\n    /**\n     * Looks for differences between the two arrays and turns on or off new directions\n     * eg: The examples in the parameters below will send a key event to the emulator with keyup for left\n     * @param was the array from the previous iteration (eg: ['left', 'up'])\n     * @param is the array from the previous iteration (eg: ['up'])\n     */\n    private processDirectionChange = (was, is) => {\n\n\n        let hide = this.nullIfEmpty(was.join('-')) || \"centre\";\n        let show = this.nullIfEmpty(is.join('-')) || \"centre\";\n\n        if (hide !== show) {\n            document.getElementById(hide).style.display = 'none'\n            document.getElementById(show).style.display = 'block'\n        }\n\n        let turnOff = was.filter(w => is.indexOf(w) === -1)\n        let turnOn = is.filter(i => was.indexOf(i) === -1)\n        turnOff.forEach((direction) => {\n            this.ci.simulateKeyEvent(this.getDirectionAscii(direction), false);\n        });\n        turnOn.forEach((direction) => {\n            this.ci.simulateKeyEvent(this.getDirectionAscii(direction), true)\n        });\n    }\n\n    private nullIfEmpty = (s) => {\n        if (!s) return null;\n        if (s.length === 0) return null;\n        return s;\n    }\n\n    /**\n     * Returns the ascii code for the corresponding arrow key\n     * @param direction\n     * @private\n     */\n    private getDirectionAscii(direction:string):number {\n        return this.directionMapping[direction];\n    }\n\n    /**\n     * Convert radians tp degrees\n     * @param rad the angle in radians\n     */\n    private radToDeg = (rad) => {\n        return Math.round(rad * 180 / Math.PI);\n    }\n\n    /**\n     * Set the starting point (touch)\n     * @param touchEvent the touch event where the movement started\n     * @private\n     */\n    private setOrigin(touchEvent:Touch) {\n        this.origin = {x:touchEvent.clientX, y:touchEvent.clientY, id:touchEvent.identifier}\n    }\n\n    /**\n     * When a user clicks away, unload the WASM code\n     * @private\n     */\n    private unload() {\n        this.dosRef.exit();\n    }\n\n}\n"],"names":["dosRef","options","canvas","forceKeyPress","this","x","y","id","up","down","left","right","directionAscii","_this","directionMapping","was","is","hide","nullIfEmpty","join","show","document","getElementById","style","display","turnOff","filter","w","indexOf","turnOn","i","forEach","direction","ci","simulateKeyEvent","getDirectionAscii","s","length","rad","Math","round","PI","DosGame","Promise","resolve","cycles","wdosboxUrl","onprogress","log","ready","fs","main","extract","zipFile","then","execCmdArray","window","focus","addEventListener","unload","dosboxConf","push","createFile","targetKey","replacementKeyCode","keysToReplace","addKeyEventListeners","directions","buttons","addTouchEventListeners","dPadElem","dPadBounds","getBoundingClientRect","dPadMode","buttonMapping","asciiCode","wait","reject","setTimeout","simulateKeyPress","callback","delay","addPixelListener","interval","setInterval","doIntervalPoll","bind","pixelListeners","lastColor","undefined","canvasContext","getContext","generalPixelCallback","clearInterval","console","toDataURL","colors","pl","pixelColor","getImageData","colorValue","getHexValue","data","number","toString","slice","handleKeyEvent","touchEventListenersAdded","handleTouchEvent","event","type","metaKey","keyCode","findReplacementKeyCode","key","keysDown","includes","splice","stopImmediatePropagation","stopPropagation","preventDefault","find","item","changedTouches","startingTouch","clientX","setOrigin","j","xPct","width","yPct","clientY","top","height","mapping","rect","element","x1","x2","y1","y2","movingTouch","control","dx","origin","dy","isNaN","rangeInner","rangeOuter","abs","error","processDirectionChange","lastDirection","identifier","touchEvent","exit","navigator","maxTouchPoints","msMaxTouchPoints"],"mappings":"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"}