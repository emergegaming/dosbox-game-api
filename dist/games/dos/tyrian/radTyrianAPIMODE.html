<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/css/tailwind.min.css"/>
    <style lang="css">

        @media screen and (orientation:portrait) {
            #canvasContainer, #canvasContainer canvas {
                width: 100%;
                position: absolute;
                top: 0;
            }
        }

        @media screen and (orientation:landscape) {
            #canvasContainer {
                background-color: #000000;
            }
            #canvasContainer canvas {
                margin-right: 200px;
                height:100vh;
            }
        }

        .emulator-canvas {
            top: 0 !important;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
        }

    </style>
    <title>Document</title>
</head>
<body class="bg-black h-screen object-contain">
    <div id="gameContainer">
        <canvas id="controlCanvas" class="w-full left-0 absolute h-screen z-50"></canvas>
        <div id="canvasContainer" class="w-full left-0 absolute top-0 h-screen"></div>
    </div>
    <script src="/dosbox/dos7/js-dos.js"></script>
    <!-- <script src="/gamePad.js"></script> -->


    <script type="module">
        let canvasContainer = document.getElementById('canvasContainer');

        import {DosGame} from "/index7.js";
        import {GpApi} from "/gamePad.js";

        let ci; 
        let arrButtonsWas = [];
        let arrButtonsIs = [];
        let gamepads;
        //let translateGamePad = new Map();

        let dosGame = new DosGame(window.Dos, canvasContainer, emulators);
        let gpApi = new GpApi(window, dosGame);
        dosGame.start7("tsf.zip").then(() => {

            gpApi.translateGamePad.set(14, 37)//left
            gpApi.translateGamePad.set(15, 39)//right
            gpApi.translateGamePad.set(12, 38)//up 
            gpApi.translateGamePad.set(13, 40)//down 
            gpApi.translateGamePad.set(0, 13)//enter
            gpApi.translateGamePad.set(7, 32)//shoot 
            gpApi.translateGamePad.set(4, 17)//kit1 
            gpApi.translateGamePad.set(5, 18)//kit2
            gpApi.translateGamePad.set(1, 27)//esc

        gpApi.addEvtListener();
        gpApi.pollGamePads();
        gpApi.gameLoop();

        });

        let buttons = [
            {
                'icon': '/images/icons/fire.svg',
                'colour' : 0xff0000,
                'press': () => pressKey(32, true),
                'release': () => pressKey(32, false),
            },
            {
                'icon': '/images/icons/bomb.svg',
                'colour' : 0xff7700,
                'press': () => pressKey(66, true),
                'release': () => pressKey(66, false),
            },
            {
                'icon': '/images/icons/accelerate.svg',
                'colour' : 0x00ff00,
                'press': () => pressKey(88, true),
                'release': () => pressKey(88, false)
            },
            {
                'icon': '/images/icons/home.svg',
                'colour' : 0x0077ff,
                'press': () => pressKey(72, true),
                'release': () => pressKey(72, false)
            },
            {
                'icon': '/images/icons/invert.svg',
                'colour' : 0xff00ff,
                'press': () => pressKey(190, true),
                'release': () => pressKey(190, false)
            }
        ]


        /** DISABLE Keyboard Scrolling / Search **/
        document.addEventListener('keydown',(e) => {
            if (e.key === '/') e.preventDefault();
            if (e.key === ' ') e.preventDefault();
        })

        /** PIXI **/
        let controlCanvas = document.getElementById('controlCanvas')
        let app = new PIXI.Application({width: window.innerWidth, height: window.innerHeight, view: controlCanvas, transparent:true, autoResize:true, resizeTo:window, antialias:true});

        let glowFilter = new PIXI.filters.GlowFilter({distance:25, outerStrength:2})

        /** PIXI:Graphics **/
        let graphicsCircle = new PIXI.Graphics();
        graphicsCircle.beginFill(0x33AAFF);
        graphicsCircle.lineStyle(0);
        graphicsCircle.drawCircle(0,0,30);
        graphicsCircle.endFill();
        graphicsCircle.interactive = false;

        let graphicsRing = new PIXI.Graphics();
        graphicsRing.lineStyle(8, 0x3355FF);
        graphicsRing.drawCircle(0,0,50);
        graphicsRing.interactive = false;

        /** PIXI:Sprite **/
        let circleTexture = app.renderer.generateTexture(graphicsCircle)
        let circle = new PIXI.Sprite(circleTexture);
        circle.anchor.set(0.5)
        circle.visible = false;
        circle.alpha = 0.5
        app.stage.addChild(circle);

        let ringTexture = app.renderer.generateTexture(graphicsRing);
        let ring = new PIXI.Sprite(ringTexture)
        ring.anchor.set(0.5)
        ring.visible = false;
        ring.alpha = 0.5
        ring.blendMode = PIXI.BLEND_MODES.ADD;
        app.stage.addChild(ring);

        for (let i = 0; i < buttons.length ; i++) {

            let graphicsButton = new PIXI.Graphics();
            graphicsButton.beginFill(buttons[i].colour);
            graphicsButton.lineStyle(0);
            graphicsButton.drawCircle(0,0,20);
            graphicsButton.endFill();

            graphicsButton.lineStyle(4, buttons[i].colour);
            graphicsButton.drawCircle(0,0,25);

            let buttonTexture = app.renderer.generateTexture(graphicsButton);

            let button = new PIXI.Sprite(buttonTexture);
            button.anchor.set(0.5)

            let svgTexture = new PIXI.Texture.from(buttons[i].icon);

            let svgSprite = new PIXI.Sprite(svgTexture);
            svgSprite.anchor.set(0.5);

            let buttonContainer = new PIXI.Container();
            buttonContainer.addChild(button);
            buttonContainer.addChild(svgSprite);


            buttonContainer.get

            buttonContainer.alpha = 0.5;
            buttons[i].sprite = buttonContainer
            app.stage.addChild(buttonContainer);
        }
        
        /** Controller Button Mappings **/

        // buttons[12].keyCode = 37;  // space (shoot)
        // buttons[13].keyCode = 38;  // b (bomb)
        // buttons[14].keyCode = 39; // . (invert)
        // buttons[15].keyCode = 40;  // h (home)
        

        repositionButtons();

        /** Variables **/

        let mouseState = 'none';
        let xc = 0, yc = 0;
        let lastX = 0; let lastY = 0;
        let lastDirection = [];
        let directionMapping = {
            'up': 265,
            'down': 264,
            'left':188,
            'right':191
        };

        /** Events **/

        app.stage.interactive = true;
        app.renderer.plugins.interaction.on('pointerdown', (event) => { /** MOUSEDOWN **/
            let x = event.data.global.x;
            let y = event.data.global.y;
            if (x < screen.width / 2) {
                xc = x;
                yc = y;
                mouseState = 'just-down'
            } else {
                for (let i = 0; i < buttons.length; i++) {
                    if (Math.abs(buttons[i].sprite.position.x - x) < 25 && Math.abs(buttons[i].sprite.position.y - y) < 25 ) {
                        buttons[i].active = true;
                        buttons[i].sprite.alpha = 1
                        buttons[i].press();
                        window.navigator.vibrate(20);
                        buttons[i].sprite.filters = [
                            glowFilter
                        ]
                    }
                }
            }
        });

        app.renderer.plugins.interaction.on('pointermove', (event) => { /** MOUSEMOVE **/
            let x = event.data.global.x;
            let y = event.data.global.y;
            if (x < window.innerWidth / 2  && y < window.innerHeight && x > 0 && y > 0) {
                xc = x;
                yc = y;
            } else {
                xc = lastX;
                yc = lastY;
            }
        })

        app.renderer.plugins.interaction.on('pointerup', (event) => { /** MOUSEUP **/
            let x = event.data.global.x;
            if (x < window.innerWidth / 2) {
                mouseState = 'just-up'
            } else {
                for (let i = 0; i < buttons.length; i++) {
                    let b = buttons[i];
                    if (b.active) {
                        b.active = false;
                        console.log ('release')
                        window.navigator.vibrate(3);
                        buttons[i].sprite.alpha = 0.5
                        buttons[i].release();
                        buttons[i].sprite.filters = [
                        ]
                    }
                }
            }
        });

        function getGamepadState(gamePads) {
            let temp = gamePads[0].buttons;
                let state = [];
                let tLength = temp.length;
                for (let i = 0; i < tLength; i++) {
                    state[i] = temp[i].pressed;
                }
                return state;
        }

        /** Main Loop **/

        gpApi.processGamePad();

        app.ticker.add(() => {
           

            if (mouseState === 'just-down') {
                circle.position.x = xc;
                circle.position.y = yc;

                circle.visible = true;
                ring.visible = true;

                ring.position.x = circle.position.x;
                ring.position.y = circle.position.y;

                mouseState = 'down'
            }

            if (mouseState === 'down') {

                circle.position.x = xc;
                circle.position.y = yc;

                let xr = ring.position.x;
                let yr = ring.position.y;

                let dx = xc - xr;
                let dy = yc - yr;
                let control = [];

                let r = Math.hypot(dx, dy);

                if (r > 7 && r < 50) {
                    let rangeInner = dy * 0.38;
                    let rangeOuter = dy * 2.61;
                    if (dx < -Math.abs(rangeOuter)) {
                        control = ['left']
                    } else if (dy < 0 && dx < rangeInner) {
                        control = ['up','left']
                    } else if (dy < 0 && dx < Math.abs(rangeInner)) {
                        control = ['up']
                    } else if (dy < 0 && dx < -rangeOuter) {
                        control = ['up','right']
                    } else if (dx > Math.abs(rangeOuter)) {
                        control = ['right']
                    } else if (dy > 0 && dx < -Math.abs(rangeInner)) {
                        control = ['down','left']
                    } else if (dy > 0 && dx < rangeInner) {
                        control = ['down']
                    } else if (dy > 0 && dx < dy * rangeOuter) {
                        control = ['down','right']
                    } else {
                        console.error ("Not a known angle / direction")
                    }
                    processDirectionChange(lastDirection, control)
                    lastDirection = control;
                }

                if (r > 50) {
                    let xDiff = xc - lastX;
                    let yDiff = yc - lastY;
                    ring.position.x += xDiff;
                    ring.position.y += yDiff;
                }
            }

            if (mouseState === 'just-up') {

                circle.visible = false;
                ring.visible = false

                mouseState = 'up'
                processDirectionChange(lastDirection, [])
                lastDirection = []
            }

            lastX = xc;
            lastY = yc;

        })

        function processDirectionChange (was, is) {

            let turnOff = was.filter(w => is.indexOf(w) === -1)
            let turnOn = is.filter(i => was.indexOf(i) === -1)

            turnOff.forEach((direction) => {
                console.log(direction + ' off');
                window.navigator.vibrate(3);
                let ascii = getDirectionAscii(direction)
                if (ascii) dosGame.ci.sendKeyEvent(DosGame.reverseKeyMap.get(ascii), false);
            });

            turnOn.forEach((direction) => {
                console.log(direction + ' on');
                window.navigator.vibrate(20);
                let ascii = getDirectionAscii(direction)
                if (ascii) dosGame.ci.sendKeyEvent(DosGame.reverseKeyMap.get(ascii), true);
            });
        }

        function getDirectionAscii(direction) {
            return directionMapping[direction];
        }

        function nullIfEmpty(s) {
            if (!s) return null;
            if (s.length === 0) return null;
            return s;
        }

        function repositionButtons() {
            let xStart = (window.innerWidth - 60)
            let yStart = window.innerHeight - 40;

            for (let i = 0; i < buttons.length ; i++) {
                let offSet = (i % 2 * -1 - 1) * 35;
                console.log (offSet);
                buttons[i].sprite.position.x = xStart + offSet;
                buttons[i].sprite.position.y = yStart + (-i * 50) ;
                buttons[i].sprite.visible = true;
            }
        }

        function pressKey(keyCode, isPressed) {
            dosGame.sendKeyEvent(DosGame.jsdosKeyCodeLookup(keyCode), isPressed);
        }

        window.addEventListener("resize", () => {
            repositionButtons();
        })
        


    </script>
<script src="/dosbox/dos7/js-dos.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
<script src="/lib/pixi-filters.js"></script>
</body>
</html>