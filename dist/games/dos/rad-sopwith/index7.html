<!DOCTYPE html>
<html lang="en">
<head>
    <title>RADICAL SOPWITH</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" type="text/css" href="/css/tailwind.min.css"/>
    <style lang="css">

        @media screen and (orientation:portrait) {
            #canvasContainer, #canvasContainer canvas {
                width: 100%;
                position: absolute;
                top: 0;
            }
        }

        @media screen and (orientation:landscape) {
            #canvasContainer, #canvasContainer canvas {
                margin: auto;
                height:100%;
                position: absolute;
            }
        }

        .emulator-canvas {
    top: 0 !important;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
}

    </style>
</head>
<body class="bg-black h-screen object-contain">
    <div id="gameContainer">
        <canvas id="controlCanvas" class="w-full left-0 absolute h-screen z-50"></canvas>
        <!-- <canvas id="gameCanvas"></canvas> -->
        <div id="canvasContainer" class="w-full left-0 absolute top-0 h-screen"></div>
    </div>
    <script src="/dosbox/dos7/js-dos.js"></script>
    
    <script type="module">

        /** DOS **/

        import {DosGame} from "/index7.js";

        let gameContainer = document.getElementById('gameContainer');
        let canvasContainer = document.getElementById('canvasContainer');



        // let canvas = document.getElementById('canvasContainer');
        // let container = document.getElementById('container');

        // let gameConfig = {
        //     zipFile : 'sopwith.zip',
        //     execCmdArray : ['-c','SOPWITH.EXE'],
        //     cycles: '800'
        // }

        // let gameConfig = {
        //     zipFile : '../alley-cat/AlleyCat.zip',
        //     execCmdArray : ['-c','cd ALLEYCAT', '-c', 'CAT.EXE'],
        //     cycles : 'fixed 3000',
        // }

        let ci; 
        let arrButtonsWas = [];
        let arrButtonsIs = [];
        var gamepads;
        let translateGamePad = new Map();
      
            

        let dosGame = new DosGame(window.Dos, canvasContainer, emulators);
            dosGame.start7("sopwith.jsdos").then(() =>{

              
        
            translateGamePad.set(0, 32)
            translateGamePad.set(1, 66)
            translateGamePad.set(2, 72)
            translateGamePad.set(3, 190)
            translateGamePad.set(5, 88)
            translateGamePad.set(14, 188)
            translateGamePad.set(15, 191)
            
      
  
      
      window.addEventListener("gamepadconnected", function() {
        var gp = navigator.getGamepads()[0];

        gameLoop();
      });
      
      window.addEventListener("gamepaddisconnected", function() {
        gamepadInfo.innerHTML = "Waiting for gamepad.";
      
        
      });
      
      if(!('GamepadEvent' in window)) {
        // No gamepad events available, poll instead.
        var interval = setInterval(pollGamepads, 500);
      }
      
      function pollGamepads() {
        var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
        for (var i = 0; i < gamepads.length; i++) {
          var gp = gamepads[i];
          //console.log("POLLING GAMEPADS")
          if(gp) {
            
            
            clearInterval(interval);
          }
        }
      }
      
      function buttonPressed(b) {
        if (typeof(b) == "object") {
          return b.pressed;
        }
        return b == 1.0;
      }
      
      function gameLoop() {
        gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
        if (!gamepads)
          return;

        // console.log(gamepads)

        //let arrButtonsIs =  gamepads[0].buttons;
      
        //var gp = gamepads[0];
        let bX = 0;
        let bO = 1;
        let bSq = 2;
        let bTr = 3;
        let bL1 = 4;
        let bR1 = 5;
        let bL2 = 6;
        let bR2 = 7;
        let bBack = 8;
        let bStart = 9;
        let bLSC = 10;
        let bRSC = 11;
        let bDPUp = 12;
        let bDPDown = 13;
        let bDPLeft = 14;
        let bDPRight = 15;
        let bHome = 16;
        let bTrackPad = 17;

        
        

        // processControllerChange(arrButtonsWas, arrButtonsIs);
        // arrButtonsWas = arrButtonsIs;


      
        // if (buttonPressed(gp.buttons[bX])) {
        //   console.log(translateGamePad.get(bX));
         
        // } else if (buttonPressed(gp.buttons[2])) {
        //   console.log(translateGamePad.get(bSq));
          
        // } else if(buttonPressed(gp.buttons[1])) {
        //   console.log(translateGamePad.get(bO));
          
        // } else if(buttonPressed(gp.buttons[3])) {
        //   console.log(translateGamePad.get(bTr));
          
        // } else if(buttonPressed(gp.buttons[4])) {
        //   console.log(translateGamePad.get(bL1));
         
        // } else if(buttonPressed(gp.buttons[5])) {
        //   console.log(translateGamePad.get(bR1));
          
        // } else if(buttonPressed(gp.buttons[6])) {
        //   console.log(translateGamePad.get(bL2));
          
        // } else if(buttonPressed(gp.buttons[7])) {
        //   console.log(translateGamePad.get(bR2));
         
        // } else if(buttonPressed(gp.buttons[8])) {
        //   console.log(translateGamePad.get(bBack));
          
        // } else if(buttonPressed(gp.buttons[9])) {
        //   console.log(translateGamePad.get(bStart));
         
        // } else if(buttonPressed(gp.buttons[10])) {
        //   console.log(translateGamePad.get(bLSC));
         
        // } else if(buttonPressed(gp.buttons[11])) {
        //   console.log(translateGamePad.get(bRSC));
          
        // } else if(buttonPressed(gp.buttons[12])) {
        //   console.log(translateGamePad.get(bDPUp));
         
        // } else if(buttonPressed(gp.buttons[13])) {
        //   console.log(translateGamePad.get(bDPDown));
          
        // } else if(buttonPressed(gp.buttons[14])) {
        //   console.log(translateGamePad.get(bDPLeft));
        //   //dosGame.autoKeyPress(88, 2);
        // } else if(!buttonPressed(gp.buttons[14])) {
        //     dosGame.ci.sendKeyEvent(88, false);
        // } else if(buttonPressed(gp.buttons[15])) {
        //   console.log(translateGamePad.get(bDPRight));
         
        // } else if(buttonPressed(gp.buttons[16])) {
        //   console.log(translateGamePad.get(bHome));
          
        // } else if(buttonPressed(gp.buttons[17])) {
        //   console.log(translateGamePad.get(bTrackPad));
          
        // }
      
    
       // var start = rAF(gameLoop);
      };
      
      
            //ci = commandInterface;

        const layers = emulatorsUi.dom.layers(document.getElementById("gameContainer"));

        for (let index = 0; index < layers.length; index++) {
            //console.log(layers[index]);
            
            
        }
            /** Auto-press on startup **/

            setTimeout(() => {
                //console.log("s")
                dosGame.autoKeyPress(83);
            }, 500)

            setTimeout(() => {
                //console.log("3")
                dosGame.autoKeyPress(51);
            }, 1000)

        });

        /** PIXI **/
        let controlCanvas = document.getElementById('controlCanvas')
        let app = new PIXI.Application({width: window.innerWidth, height: window.innerHeight, view: controlCanvas, transparent:true, autoResize:true, resizeTo:window});

        /** PIXI:Graphics **/
        let graphicsCircle = new PIXI.Graphics();
        graphicsCircle.beginFill(0x33AAFF);
        graphicsCircle.lineStyle(0);
        graphicsCircle.drawCircle(0,0,30);
        graphicsCircle.endFill();
        graphicsCircle.interactive = false;

        let graphicsRing = new PIXI.Graphics();
        graphicsRing.lineStyle(8, 0x3355FF);
        graphicsRing.drawCircle(0,0,50);
        graphicsRing.interactive = false;

        let graphicsButton = new PIXI.Graphics();
        graphicsButton.beginFill(0x33AAFF);
        graphicsButton.lineStyle(0);
        graphicsButton.drawCircle(0,0,20);
        graphicsButton.endFill();

        graphicsButton.lineStyle(4, 0x33CCCC);
        graphicsButton.drawCircle(0,0,25);


        /** PIXI:Sprite **/
        let circleTexture = app.renderer.generateTexture(graphicsCircle)
        let circle = new PIXI.Sprite(circleTexture);
        circle.anchor.set(0.5)
        circle.visible = false;
        circle.alpha = 0.5
        app.stage.addChild(circle);

        let ringTexture = app.renderer.generateTexture(graphicsRing);
        let ring = new PIXI.Sprite(ringTexture)
        ring.anchor.set(0.5)
        ring.visible = false;
        ring.alpha = 0.5
        ring.blendMode = PIXI.BLEND_MODES.ADD;
        app.stage.addChild(ring);

        let buttonTexture = app.renderer.generateTexture(graphicsButton);
        let buttons = [];
        for (let i = 0; i < 5 ; i++) {

            let button = new PIXI.Sprite(buttonTexture);
            button.anchor.set(0.5)
            button.alpha = 0.5;
            button.x = 100;
            button.visible = false;

            buttons.push(button)
            app.stage.addChild(buttons[i]);
        }

        buttons[0].keyCode = 32;  // space (shoot)
        buttons[1].keyCode = 66;  // b (bomb)
        buttons[2].keyCode = 190; // . (invert)
        buttons[3].keyCode = 72;  // h (home)
        buttons[4].keyCode = 88;  // x (go)

        repositionButtons();

        /** Variables **/

        let mouseState = 'none';
        let xc = 0, yc = 0;
        let lastX = 0; let lastY = 0;
        let lastDirection = [];
        let directionMapping = {
            'up': null,
            'down':null,
            'left':188,
            'right':191
        };

        /** Events **/

        app.stage.interactive = true;
        app.renderer.plugins.interaction.on('pointerdown', (event) => { /** MOUSEDOWN **/
            let x = event.data.global.x;
            let y = event.data.global.y;
            if (x < screen.width / 2) {
                xc = x;
                yc = y;
                mouseState = 'just-down'
            } else {
                for (let i = 0; i < 5; i++) {
                    if (Math.abs(buttons[i].position.x - x) < 25 && Math.abs(buttons[i].position.y - y) < 25 ) {
                        buttons[i].active = true;
                    dosGame.ci.sendKeyEvent(buttons[i].keyCode, true);
                    }
                }
            }
            if (!document.fullscreenElement) {
                gameContainer.requestFullscreen();
            }
        });

        app.renderer.plugins.interaction.on('pointermove', (event) => { /** MOUSEMOVE **/
            let x = event.data.global.x;
            let y = event.data.global.y;
            if (x < window.innerWidth / 2  && y < window.innerHeight && x > 0 && y > 0) {
                xc = x;
                yc = y;
            } else {
                xc = lastX;
                yc = lastY;
            }
        })

        app.renderer.plugins.interaction.on('pointerup', (event) => { /** MOUSEUP **/
            let x = event.data.global.x;
            if (x < window.innerWidth / 2) {
                mouseState = 'just-up'
            } else {
                for (let i = 0; i < 5; i++) {
                    let b = buttons[i];
                    if (b.active) {
                        b.active = false;
                        dosGame.ci.sendKeyEvent(b.keyCode, false);
                    }
                }
            }

        });

        function getGamepadState(gamePads) {
            let temp = gamePads[0].buttons;
            let state = [];
            let tLength = temp.length;
            for (let i = 0; i < tLength; i++) {
                state[i] = temp[i].pressed;
            }
            return state;
        }

        /** Main Loop **/
        
        //arrButtonsWas = arrButtonsIs;
        app.ticker.add(() => {


            var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
            if (!gamepads)
              return;
            


            // gamepads.forEach(gp => {
            //   if (gp.index === 0) {
            //     console.log(gp.buttons);
            //   }
            // });
            
            // console.log(gamepads[0]);
            // console.log(gamepads[1]);
            //let arrButtonsIs = [];

            

            if (gamepads.length > 0) {
                //debugger
               //console.log("AAAAAAAA")

                
                if (arrButtonsIs.length > 0 && arrButtonsWas.length > 0) {
                    arrButtonsIs = getGamepadState(gamepads);
                    processControllerChange(arrButtonsWas, arrButtonsIs);
                    arrButtonsWas = arrButtonsIs.slice(0);    
                }
                else {
                    arrButtonsIs = getGamepadState(gamepads);
                    arrButtonsWas = arrButtonsIs.slice(0);    
                }
                
            }

            

            if (mouseState === 'just-down') {
                circle.position.x = xc;
                circle.position.y = yc;

                circle.visible = true;
                ring.visible = true;

                ring.position.x = circle.position.x;
                ring.position.y = circle.position.y;

                mouseState = 'down'
            }

            if (mouseState === 'down') {

                circle.position.x = xc;
                circle.position.y = yc;

                let xr = ring.position.x;
                let yr = ring.position.y;

                let dx = xc - xr;
                let dy = yc - yr;
                let control = [];

                let r = Math.hypot(dx, dy);

                if (r > 7 && r < 50) {
                    let rangeInner = dy * 0.38;
                    let rangeOuter = dy * 2.61;
                    if (dx < -Math.abs(rangeOuter)) {
                        control = ['left']
                    } else if (dy < 0 && dx < rangeInner) {
                        control = ['up','left']
                    } else if (dy < 0 && dx < Math.abs(rangeInner)) {
                        control = ['up']
                    } else if (dy < 0 && dx < -rangeOuter) {
                        control = ['up','right']
                    } else if (dx > Math.abs(rangeOuter)) {
                        control = ['right']
                    } else if (dy > 0 && dx < -Math.abs(rangeInner)) {
                        control = ['down','left']
                    } else if (dy > 0 && dx < rangeInner) {
                        control = ['down']
                    } else if (dy > 0 && dx < dy * rangeOuter) {
                        control = ['down','right']
                    } else {
                        console.error ("Not a known angle / direction")
                    }
                    processDirectionChange(lastDirection, control)
                    lastDirection = control;
                }

                if (r > 50) {
                    let xDiff = xc - lastX;
                    let yDiff = yc - lastY;
                    ring.position.x += xDiff;
                    ring.position.y += yDiff;
                }
            }

            if (mouseState === 'just-up') {

                circle.visible = false;
                ring.visible = false;

                mouseState = 'up'
                processDirectionChange(lastDirection, [])
                lastDirection = []
            }

            lastX = xc;
            lastY = yc;

        })

        function processDirectionChange (was, is) {

            window.navigator.vibrate(20);

            let turnOff = was.filter(w => is.indexOf(w) === -1)
            let turnOn = is.filter(i => was.indexOf(i) === -1)

            turnOff.forEach((direction) => {
                //console.log(direction + ' off');
                let ascii = getDirectionAscii(direction)
                //console.log(ascii)
                if (ascii) dosGame.ci.sendKeyEvent(DosGame.reverseKeyMap[ascii], false);

            });

            turnOn.forEach((direction) => {
                //console.log(direction + ' on');
                let ascii = getDirectionAscii(direction)
                //console.log(ascii)
                if (ascii) dosGame.ci.sendKeyEvent(DosGame.reverseKeyMap[ascii], true);
            });
        }
        function processControllerChange (was, is) {
            // console.log(is);
            // console.log(was);
        let changes = [];
        
        
        if (is && was) {
            
        // console.log("WAS: ", was)
        // console.log("IS: ", is)

            
            //changes = is.map((item, index) => {(item !== was[index] ? item : null)}); 
            
            for (let i = 0; i < is.length; i++) {
                if (is[i] !== was[i]) {
                    // console.log(i);
                    changes.push({keyCode:(translateGamePad.get(i)), action:(is[i])});
                }
                
            }
        }
//{keyCode:(translateGamePad.get(index)), action:(item)}

            
        //console.log("IS: " + is[0].pressed, "WAS: " + was[0])
        //console.log("CHANGES", changes);
        if (changes.length>0) {
            //console.log(changes);
         
            changes.forEach(requiredKeyPress => {
                dosGame.ci.sendKeyEvent(dosGame.reverseKeyMap.get(requiredKeyPress.keyCode), requiredKeyPress.action);
                //console.log (dosGame.reverseKeyMap.get(requiredKeyPress.keyCode), requiredKeyPress.action);
            })   
        }

        
        //   console.log("ProcessControllerChange");
        //   console.log(was);
        //   console.log(is);

            

        //   let turnOff = is.map((isItem, index) => isItem.pressed !== was[index].pressed  && is[index].pressed === false ? index : false).filter((i) => i !== false);
        //   let turnOn = was.map((wasItem, index) => wasItem.pressed !== is[index].pressed && is[index].pressed === true ? index : false).filter((i) => i !== false);

        //     turnOff.forEach((button) => {
        //       let tButton = translateGamePad.get(button);
        //         //console.log(tButton + ' off');
        //         //let ascii = getDirectionAscii(direction)
        //         //console.log(tButton)
        //         if (button) console.log(tButton)//dosGame.ci.sendKeyEvent(tButton, false);

        //     });

        //     turnOn.forEach((button) => {
        //       let tButton = translateGamePad.get(button);
        //         //console.log(tButton + ' off');
        //         //let ascii = getDirectionAscii(direction)
        //         //console.log(tButton)
        //         if (button) console.log(tButton)//dosGame.ci.sendKeyEvent(tButton, false);
        //     });
        }

        function getDirectionAscii(direction) {
            return directionMapping[direction];
        }

        function nullIfEmpty(s) {
            if (!s) return null;
            if (s.length === 0) return null;
            return s;
        }

        function repositionButtons() {
            let xStart = (window.innerWidth - 80)
            let yStart = window.innerHeight - 70;

            for (let i = 0; i < 5; i++) {
                buttons[i].position.x = xStart;
                buttons[i].position.y = yStart + (-i * 60);
                buttons[i].visible = true;
            }
        }


        window.addEventListener("resize", () => {
            repositionButtons();
        })

    </script>
    <script>
        
      </script>
    <script src="/dosbox/dos7/js-dos.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
</body>
</html>
